package main

import (
	"context"
	"encoding/json"
	"flag"
	"github.com/fasthttp/websocket"
	"github.com/redis/go-redis/v9"
	"log"
	"net/http"
	"time"
)

var addr = flag.String("addr", "localhost:8080", "http service address")
var upgrader = websocket.Upgrader{} // use default options

var WSMessages = make(chan Transaction)

func echo(w http.ResponseWriter, r *http.Request) {
	c, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Print("upgrade:", err)
		return
	}
	defer c.Close()

	for msg := range WSMessages {
		err = c.WriteJSON(msg)
		if err != nil {
			log.Println("write:", err)
			break
		}
	}
}

func sendToWs(tx Transaction) {
	c.WriteJSON(msg)
}

func main() {
	var txCounter = 0
	var prevTxCounter = 0

	ctx := context.Background()
	rdb := redis.NewClient(&redis.Options{
		Addr:     "redis-master:6379",
		Password: "", // no password set
		DB:       2,  // use default DB
		PoolSize: 100,
	})

	// There is no error because go-redis automatically reconnects on error.
	pubsub := rdb.Subscribe(ctx, "transaction")

	// Close the subscription when we are done.
	defer pubsub.Close()

	ch := pubsub.Channel()

	// Periodic task
	ticker := time.NewTicker(time.Second)
	quit := make(chan struct{})
	go func() {
		for {
			select {
			case <-ticker.C:
				diff := txCounter - prevTxCounter
				prevTxCounter = txCounter

				topPeers := rdb.ZRange(ctx, "peers", 0, 9)
				log.Println(topPeers)

				log.Printf("TXs processed: %d; TPS: %d", txCounter, diff)
			case <-quit:
				ticker.Stop()
				return
			}
		}
	}()

	go func() {
		http.HandleFunc("/", echo)
		log.Fatal(http.ListenAndServe(*addr, nil))
	}()

	// Process pub/sub messages
	for msg := range ch {
		tx := Transaction{}
		err := json.Unmarshal([]byte(msg.Payload), &tx)
		if err != nil {
			log.Println("read:", err)
			return
		}

		enode, err := rdb.Get(ctx, tx.TxHash).Result()
		switch {
		case err == redis.Nil:
			rdb.Set(ctx, tx.TxHash, tx.Peer, 0)
			rdb.ZAdd(ctx, "peers", redis.Z{
				Score:  float64(1),
				Member: tx.Peer,
			})
			continue
		case err != nil:
			log.Println("Get failed", err)
			continue
		case enode == "":
			log.Println("value is empty")
			continue
		}

		rdb.ZIncrBy(ctx, "peers", float64(1), enode)
		txCounter += 1
	}
}
